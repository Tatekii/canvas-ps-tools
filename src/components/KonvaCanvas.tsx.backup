import React, { useRef, useEffect, useState, useCallback } from "react"
import { Stage, Layer, Image as KonvaImage } from "react-konva"
import { KonvaEventObject } from "konva/lib/Node"
import Konva from "konva"
import { SelectionManager } from "../utils/SelectionManager"
import { getShortcutHints } from "../utils/KeyboardUtils"
import { getDisplayDimensions, getCenteredPosition } from "../utils/TransformUtils"
import { useSelectionMode } from "../hooks/useSelectionMode"
import { useKonvaMouseEvent } from "../hooks/useKonvaMouseEvent"
import { ZoomControls } from "./ZoomControls"
import { KonvaSelectionOverlay, KonvaSelectionRenderer } from "./KonvaSelectionOverlay"
import { KonvaToolPreview } from "./KonvaToolPreview"
import { KonvaLayerRenderer } from "./KonvaLayerRenderer"
import { EditToolTypes } from "../constants"
// 导入新的 Zustand stores
import { 
  useViewport, 
  useCanvasReady,
  useZoomControls,
  usePanControls,
  useSetStageRef,
  useSetReady,
  useUpdateViewportTransform
} from "../stores/canvasStore"
import {
  useActiveSelection,
  useSelectionActions
} from "../stores/selectionStore"
import {
  useMagicWandTool,
  useLassoTool,
  useRectangleTool,
  useEllipseTool,
  useBrushTool,
  useHiddenCanvas,
  useSelectionManagerFromStore,
  useInitializeTools,
  useSetHiddenCanvas,
  useSetSelectionManager
} from "../stores/toolInstanceStore"
import {
  useLayerStore
} from "../stores/layerStore"

interface KonvaCanvasRef {
	clearSelection: () => void
	deleteSelected: () => void
	invertSelection: () => void
	selectAll: () => void
}

interface KonvaCanvasProps {
	selectedTool: EditToolTypes
	tolerance: number
	onSelectionChange: (hasSelection: boolean, area?: number) => void
}

const KonvaCanvas = React.forwardRef<KonvaCanvasRef, KonvaCanvasProps>(
	({ selectedTool, tolerance, onSelectionChange }, ref) => {
		// 从 Zustand stores 获取状态
		const viewport = useViewport()
		const isCanvasReady = useCanvasReady()
		const zoomControls = useZoomControls()
		const panControls = usePanControls()
		const setStageRef = useSetStageRef()
		const setReady = useSetReady()
		const updateViewportTransform = useUpdateViewportTransform()
		
		const activeSelection = useActiveSelection()
		const selectionActions = useSelectionActions()
		
		// 图层系统
		const layerStore = useLayerStore()

		// 舞台尺寸常量 (将逐步迁移到 store)
		const STAGE_WIDTH = 1080
		const STAGE_HEIGHT = 768
		const MAX_IMAGE_WIDTH = 1080
		const MAX_IMAGE_HEIGHT = 720

		const stageRef = useRef<Konva.Stage>(null)
		const fileInputRef = useRef<HTMLInputElement>(null)
		const containerRef = useRef<HTMLDivElement>(null)
		
		// 初始化 canvas store 的 stage ref
		useEffect(() => {
			if (stageRef.current) {
				setStageRef(stageRef as React.RefObject<Konva.Stage>)
			}
		}, [setStageRef])

		// Canvas相关状态 - 从 toolInstanceStore 管理
		const hiddenCanvas = useHiddenCanvas()
		const setHiddenCanvas = useSetHiddenCanvas()

		// 工具实例状态 - 从 toolInstanceStore 管理
		const selectionManager = useSelectionManagerFromStore()
		const setSelectionManager = useSetSelectionManager()
		const magicWandTool = useMagicWandTool()
		const lassoTool = useLassoTool()
		const rectangleTool = useRectangleTool()
		const ellipseTool = useEllipseTool()
		const brushTool = useBrushTool()
		const [konvaSelectionRenderer] = useState<KonvaSelectionRenderer | null>(null)
		const initializeTools = useInitializeTools()

		// 使用自定义Hook处理选区模式和键盘事件
		const { shortcutText } = useSelectionMode({
			selectedTool,
			hasImage: layerStore.layers.length > 0, // 改为检查是否有图层
			enableKeyboardControl: true,
		})

		// 获取快捷键提示
		const shortcuts = getShortcutHints()

		// 处理容差变化
		useEffect(() => {
			if (magicWandTool && tolerance !== undefined) {
				magicWandTool.setTolerance(tolerance)
			}
		}, [tolerance, magicWandTool])

		// 使用统一的鼠标事件处理Hook
		const { handleMouseDown, handleMouseMove, handleMouseUp } = useKonvaMouseEvent({
			selectedTool,
			image,
			isCanvasReady,
			magicWandTool,
			lassoTool,
			rectangleTool,
			ellipseTool,
			brushTool,
			selectionManager,
			konvaSelectionRenderer: null, // 暂时设为 null，待重构
			onSelectionChange,
			setSelection: () => {}, // 暂时设为空函数，待重构  
			setIsDrawing: () => {}, // 使用 tool store
			setIsDragging: () => {}, // 使用 UI state
			stageRef,
			maxWidth: MAX_IMAGE_WIDTH,
			maxHeight: MAX_IMAGE_HEIGHT,
		})

		// 处理滚轮缩放
		const handleWheel = useCallback((e: KonvaEventObject<WheelEvent>) => {
			e.evt.preventDefault()

			const stage = stageRef.current
			if (!stage) return

			const scaleBy = 1.1
			const oldScale = viewport.scale
			const pointer = stage.getPointerPosition()

			if (!pointer) return

			const mousePointTo = {
				x: (pointer.x - viewport.x) / oldScale,
				y: (pointer.y - viewport.y) / oldScale,
			}

			const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy

			// 使用 store 的缩放功能
			updateViewportTransform({ 
				scale: Math.max(0.1, Math.min(5, newScale)),
				x: pointer.x - mousePointTo.x * newScale,
				y: pointer.y - mousePointTo.y * newScale
			})
		}, [viewport.scale, viewport.x, viewport.y, updateViewportTransform])

		// 加载默认图层
		const loadDefaultImage = useCallback(async () => {
			try {
				await layerStore.initializeWithDefaultLayer()
				selectionActions.clearSelection()
				onSelectionChange(false)
				// 重置舞台缩放
				zoomControls.resetZoom()
			} catch (error) {
				console.error('Failed to load default image:', error)
				alert("默认图片加载失败，请检查文件是否存在")
			}
		}, [layerStore, onSelectionChange, selectionActions, zoomControls])

		const handleImageUpload = useCallback(
			async (event: React.ChangeEvent<HTMLInputElement>) => {
				const file = event.target.files?.[0]
				if (file) {
					// 检查文件类型
					if (!file.type.startsWith("image/")) {
						alert("请选择有效的图片文件")
						return
					}

					// 检查文件大小 (限制为10MB)
					const maxSize = 10 * 1024 * 1024
					if (file.size > maxSize) {
						alert("图片文件太大，请选择小于10MB的图片")
						return
					}

					try {
						await layerStore.addLayerFromFile(file)
						selectionActions.clearSelection()
						onSelectionChange(false)
						// 重置舞台缩放
						zoomControls.resetZoom()
					} catch (error) {
						console.error('Failed to load image from file:', error)
						alert("图片加载失败，请尝试其他图片")
					}
				}
			},
			[layerStore, onSelectionChange, selectionActions, zoomControls]
		)

		// 初始化默认图层
		useEffect(() => {
			// 只在图层为空时加载默认图层
			if (layerStore.layers.length === 0) {
				loadDefaultImage()
			}
		}, [layerStore.layers.length, loadDefaultImage])

		// 清除选区
		const clearSelection = useCallback(() => {
			if (selectionManager) {
				selectionManager.clearSelection()
			}
			selectionActions.clearSelection() // 使用 store

			// 清除选区显示
			if (konvaSelectionRenderer) {
				konvaSelectionRenderer.clearSelection()
			}

			onSelectionChange(false)
		}, [selectionManager, konvaSelectionRenderer, onSelectionChange, selectionActions])

		// 删除选中区域 - 临时禁用，等待图层系统完善
		const deleteSelected = useCallback(() => {
			console.log('删除功能待图层系统完善后实现')
		}, [])
				tempCanvas.width = hiddenCanvas.width
				tempCanvas.height = hiddenCanvas.height
				const tempCtx = tempCanvas.getContext("2d")

				if (tempCtx) {
					tempCtx.putImageData(activeSelection.mask, 0, 0)
					ctx.globalCompositeOperation = "destination-out"
					ctx.drawImage(tempCanvas, 0, 0)
				}

				ctx.restore()
				clearSelection()

				// 强制重新渲染stage
				if (stageRef.current) {
					stageRef.current.batchDraw()
				}
			}
		}, [activeSelection, image, hiddenCanvas, clearSelection])

		// 反转选区
		const invertSelection = useCallback(() => {
			if (selectionManager) {
				selectionManager.invertSelection()
				const currentSelection = selectionManager.getCurrentSelectionAsImageData()

				if (selectionManager.hasSelection() && currentSelection) {
					// 使用 store 创建反选选区
					// TODO: 实现选区反转逻辑
					
					const area = selectionManager.getSelectionArea()
					onSelectionChange(true, area)
				} else {
					selectionActions.clearSelection() // 使用 store

					// 清除选区显示
					if (konvaSelectionRenderer) {
						konvaSelectionRenderer.clearSelection()
					}

					onSelectionChange(false)
				}
			}
		}, [selectionManager, konvaSelectionRenderer, onSelectionChange, selectionActions])

		// 全选
		const selectAll = useCallback(() => {
			if (selectionManager) {
				selectionManager.selectAll()
				const currentSelection = selectionManager.getCurrentSelectionAsImageData()

				if (selectionManager.hasSelection() && currentSelection) {
					// 使用Konva渲染器更新选区显示
					if (konvaSelectionRenderer) {
						konvaSelectionRenderer.renderSelection(currentSelection)
					}

					const area = selectionManager.getSelectionArea()
					onSelectionChange(true, area)
				}
			}
		}, [selectionManager, konvaSelectionRenderer, onSelectionChange])

		// 缩放控制
		const zoomIn = useCallback(() => {
			zoomControls.zoomIn()
		}, [zoomControls])

		const zoomOut = useCallback(() => {
			zoomControls.zoomOut()
		}, [zoomControls])

		const resetZoom = useCallback(() => {
			if (!image || !centeredPosition) return
			zoomControls.resetZoom()
			panControls.panTo(centeredPosition)
		}, [zoomControls, panControls, image, centeredPosition])

		// 暴露方法给父组件
		React.useImperativeHandle(
			ref,
			() => ({
				clearSelection,
				deleteSelected,
				invertSelection,
				selectAll,
			}),
			[clearSelection, deleteSelected, invertSelection, selectAll]
		)

		if (!image || !imageDimensions) {
			return (
				<div className="flex-1 bg-gray-800 p-4 flex flex-col items-center justify-center relative">
					<div className="text-center">
						<div className="border-2 border-dashed border-gray-600 rounded-lg p-12 mb-4">
							<div className="text-gray-400 mb-4">
								<svg
									className="w-16 h-16 mx-auto mb-4"
									fill="none"
									stroke="currentColor"
									viewBox="0 0 24 24"
								>
									<path
										strokeLinecap="round"
										strokeLinejoin="round"
										strokeWidth={2}
										d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
									/>
								</svg>
								<p className="text-lg font-medium">上传图片开始编辑</p>
								<p className="text-sm mt-2">支持 PNG, JPG, GIF 格式</p>
								<p className="text-sm mt-2">不超过10MB</p>
							</div>
							<div className="flex flex-col gap-3">
								<button
									onClick={() => fileInputRef.current?.click()}
									className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors duration-200"
								>
									选择图片
								</button>
								<div className="text-center">
									<span className="text-gray-500 text-sm">或者</span>
								</div>
								<button
									onClick={loadDefaultImage}
									className="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg transition-colors duration-200"
								>
									使用测试图片 (test.png)
								</button>
							</div>
						</div>
						<input
							ref={fileInputRef}
							type="file"
							accept="image/*"
							onChange={handleImageUpload}
							className="hidden"
						/>
					</div>
				</div>
			)
		}

		const { width, height } = imageDimensions

		return (
			<div className="flex-1 bg-gray-800 p-4 flex flex-col items-center justify-center relative">
				<div
					ref={containerRef}
					className="relative overflow-hidden border border-gray-600 rounded-lg shadow-lg bg-white"
				>
					<Stage
						ref={stageRef}
						width={STAGE_WIDTH}
						height={STAGE_HEIGHT}
						draggable={selectedTool === "move"}
						onMouseDown={handleMouseDown}
						onMouseMove={handleMouseMove}
						onMouseUp={handleMouseUp}
						onWheel={handleWheel}
						scaleX={viewport.scale}
						scaleY={viewport.scale}
						x={viewport.x}
						y={viewport.y}
					>
						{/* 用户定义的图层渲染器 - 每个图层包含图像+编辑功能 */}
						<KonvaLayerRenderer />
						
						{/* 通用选区层 - 全局选区显示 */}
						<Layer>
							<KonvaSelectionOverlay selection={activeSelection?.mask || null} />
						</Layer>
						
						{/* 通用工具预览层 - 全局工具预览 */}
						{previewData && (
							<Layer>
								<KonvaToolPreview previewData={previewData} />
							</Layer>
						)}
					</Stage>

					<div className="absolute top-4 right-4 bg-black bg-opacity-75 text-white rounded-lg text-sm max-w-64 p-2">
						{activeSelection && <div className="text-xs text-green-400">选区激活 ✨</div>}
						{shortcutText && <div className="text-xs text-yellow-400 mt-2">{shortcutText}</div>}
						<div className="text-xs text-blue-400 mt-2">
							Konva Canvas - 缩放: {Math.round(viewport.scale * 100)}%
						</div>
					</div>
				</div>

				{/* 快捷键提示 */}
				<div className="absolute right-4 bottom-4 text-xs text-gray-300 border border-gray-600 p-2">
					<div className="text-xs text-gray-400 mb-1">快捷键:</div>
					<div>{shortcuts.add}</div>
					<div>{shortcuts.subtract}</div>
					<div>{shortcuts.intersect}</div>
					<div className="text-xs text-gray-400 mt-2 mb-1">移动工具:</div>
					<div>拖拽: 移动画布</div>
					<div>滚轮: 缩放画布</div>
				</div>

				{/* 缩放控件 */}
				<ZoomControls zoom={viewport.scale} onZoomIn={zoomIn} onZoomOut={zoomOut} onReset={resetZoom} />
				
				{/* 临时测试按钮 - 用于测试选区功能 */}
				<div className="absolute bottom-4 left-4">
					<button
						onClick={createTestSelection}
						className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm transition-colors duration-200"
					>
						测试选区
					</button>
				</div>
			</div>
		)
	}
)

KonvaCanvas.displayName = "KonvaCanvas"

export default KonvaCanvas
